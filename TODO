LLVM code generation
  - Pass things of size 1 normally?
    * Use i64 operands for size 1 things to avoid many back-and-forth casts?
    * Make global functions keep track of their parameters' Direction
    * Make the Restrict pass use meta vars to keep track of this info
  - Return things of size 1 normally
    * Make global functions keep track of their return Direction
  - Special-case the `Ref` constructor to use gc_alloc
    deref can be a no-op to an indirect var?
    shouldn't need size to deref
  - Define builtins & apply_n functions
  - Constant functions should be evaluated in main
Do closure conversion earlier and allow by-value variable capture
Cleanup
Usage analysis for better erasure
Add new Int type
instantiate implicits at variable use sites?
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Reorder data to pass fewer sizes
    (Depends on relevance analysis and/or removal of unused args)
    Reorder data to enable tagged pointers?
Cases
  Make Concrete syntax have deep patterns and desugar them
  Normalisation
Let(rec) definitions
Laziness
Specialisation pragma
  data Strategy = Eager | Lazy

  @ : Type -> Strategy -> Type
  t @ Eager = t
  t @ Lazy = Ref (Lazy t)

  data Lazy a = Thunk (() -> a) | Blackhole | Forced a

  force : {s : Strategy} -> t @ s -> t
  force {Eager} t = t
  force {Lazy} t = run do
    x <- readRef t
    case x of
      Thunk f -> do
        writeRef t Blackhole
        let result = f ()
        writeRef t (Forced result)
        return result
      Blackhole -> error "<loop>"
      Forced result -> return result

  delay : {s : Strategy} -> (() -> t) -> t @ s
  delay {Eager} f = f ()
  delay {Lazy} f = newRef (Left f)

  data List s a = Nil | Cons a (List s a @ s)

  map : {s} -> (a -> b) -> List s a -> List s b
  map {s} = case s in \f xs. case xs of
    Nil -> Nil
    Cons x xs' -> Cons (f x) (map f xs')

  map s = case s of
    Eager -> mapEager
    Lazy  -> mapLazy

  mapEager f Nil = Nil
  mapEager f (Cons x xs) = Cons (f x) (mapEager f xs)

  mapLazy f Nil = Nil
  mapLazy f (Cons x xs) = Cons (f x) (newRef (Left (mapLazy f xs)))
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type

  Exists {X} (P : X -> Type) = {witness : x, proof : P witness}

  record {l : A | {l : B | r}} ?= record {l : A intersect B | r}
  intersection A B = {intersect : a, intersect : b}
    or not allowed?
  Parse
  Type-check
  Should make lenses?
  Codegen
Arity inference
Type classes
Test suite
Mixfix definitions and noncompounds?
Better error messages
Modules
Inductive families
