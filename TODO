Type checking
  Better checking for escaped vars
  Sanity type-check the Abstract syntax
  Use a proper higher-order unification algorithm
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
  Pattern synonyms (just normalise function applications in patterns and see if it ends up with a pattern)
Codegen
  Arity inference
  Use llvm-hs for llvm
    Make a utility function that forward-declares everything undefined you use
Parsing
  Use megaparsec instead of trifecta?
  Error recovery
Compiler
  Add printing to compiler passes that are not VIX (make a MonadLog class?)
  Simplify/make consistent all the type synonyms
  Clean up MetaVar handling (not all modules need the full generality)
  Make code generation use VIX
  Try to get rid of zonking in normal TC operation
  Implement e.g. language server protocol
Error messages
  Write own error printer
  Make error message footnotes contain metavars
  Use prettyprinter library
Language
  * Add alignment to type representation
    alignment (Tuple A B) = max (alignment A) (alignment B)
    size (Tuple A B) = size A + padding (size A) (alignment B) + size B
    padding byteIndex align = nearestBiggerMultiple align byteIndex - byteIndex
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
    Overloaded literals
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
    Re-exports
    Caching
  Mixfix definitions and noncompounds?
  * Inductive families
    Forcing
    Compute the representation of a type by pattern-matching on indices if possible, allowing the definition of e.g. flat vectors:
      type Vector n A where
        Nil : Vector 0 A
        Cons : forall {n}. A -> Vector n A -> Vector (S n) a
  FFI
    Top-level extern declarations
    Use `opt -internalize-public-api-list` to internalize extern C decls
    Extern LLVM
  IO
  Mutable variables
Optimisations
  Inlining
  Common subexpressions
  Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 8
