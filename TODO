Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying sizes be done in a principled way?
  Propagate equalities from cases
  Sanity type-check the Abstract syntax
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
Erasure
  * Make sure that we don't transform functions to non-functions by erasing all arguments.
    e.g. `loop x = loop x : Void` should not have its argument removed.
  Type-based erasure of things of size 0 (they can be invented when needed instead of passed around)
Codegen
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals, e.g. `a = a`
  Should things of known size > 1 be passed as LLVM arrays?
  Use e.g. llvm-hs-kaleidoscope for llvm?
Compiler
  Look into a class for "(bi)transverse" (monadic/applicative hoisting)?
  Add printing to compiler passes that are not TCM (make a MonadLog class?)
  * Make converted signatures contain converted exprs to get rid of the back-and-forth conversions between slambda representations?
  Simplify/make consistent all the type synonyms
  Concretise some of the Context/MetaVary nonsense
  Clean up MetaVar handling (not all modules need the full generality)
Error messages
  Write own error printer
  Make error message footnotes contain metavars
Language
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Change Size to runtime representation, which can include:
    - Allocation strategy
    - Size
    - GC info (e.g. positions of pointers)
    - Functions can be of type `Type {ClosureRep}` where ClosureRep is magic
  Can we have an Infinity size for things we can only hold in pointers?
  ListRep : max 1 (1 + sizeof A + sizeof (Ptr (List A)))
Optimisations
  Inlining
  Common subexpressions
  Case of known
  * Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
