Switch to lenses
Javascript code generation
Let definitions
Restructure codebase
ADTs and cases
  Type-check
  Codegen
Specialisation pragma
  data Strategy = Eager | Lazy

  @ : Type -> Strategy -> Type
  t @ Eager = t
  t @ Lazy = Ref (Lazy t)

  data Lazy a = Thunk (() -> a) | Blackhole | Forced a

  force : {s : Strategy} -> t @ s -> t
  force {Eager} t = t
  force {Lazy} t = run do
    x <- readRef t
    case x of
      Thunk f -> do
        writeRef t Blackhole
        let result = f ()
        writeRef t (Forced result)
        return result
      Blackhole -> error "<loop>"
      Forced result -> return result

  delay : {s : Strategy} -> (() -> t) -> t @ s
  delay {Eager} f = f ()
  delay {Lazy} f = newRef (Left f)

  data List s a = Nil | Cons a (List s a @ s)

  map : {s} -> (a -> b) -> List s a -> List s b
  map {s} = case s in \f xs. case xs of
    Nil -> Nil
    Cons x xs' -> Cons (f x) (map f xs')

  map s = case s of
    Eager -> mapEager
    Lazy  -> mapLazy

  mapEager f Nil = Nil
  mapEager f (Cons x xs) = Cons (f x) (mapEager f xs)

  mapLazy f Nil = Nil
  mapLazy f (Cons x xs) = Cons (f x) (newRef (Left (mapLazy f xs)))

Laziness
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type

  Exists {X} (P : X -> Type) = {witness : x, proof : P witness}

  record {l : A | {l : B | r}} ?= record {l : A intersect B | r}
  intersection A B = {intersect : a, intersect : b}
    or not allowed?
  Parse
  Type-check
  Should make lenses?
  Codegen
Type classes
  Parse
  Type-check
  Codegen
Test suite
Mixfix definitions and noncompounds?
Better error messages
Modules
Inductive families
