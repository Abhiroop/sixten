Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying sizes be done in a principled way?
  Propagate equalities from cases
  Error if a term's type depends on the term (i.e. x : ... x)?
Erasure
  Make sure that we don't transform functions to non-functions by erasing all arguments.
    e.g. `loop x = loop x : Void` should not have its argument removed.
Codegen
  Add Destructor calling convention for functions that return part of their argument
    To get rid of the memcpy from deref
  * Can case scrutinees and tail calls explicitly be of unspecified size?
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals, e.g. `a = a`
  Should things of known size > 1 be passed as LLVM arrays?
Compiler
  Concretise some of the Context/MetaVary nonsense
  Clean up MetaVar handling (not all modules need the full generality)
  Clean up Syntax.{Telescope,Class,Branches,Data,Definition}
  * Better error messages
Language
  Allow e.g. `True False : Bool` in data decls
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  * Mutually recursive top-level definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  Make Concrete syntax have deep patterns and desugar them
  Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Can we have an Infinity size for things we can only hold in pointers?
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Usage analysis for better erasure
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
