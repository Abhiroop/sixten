Make printing of passes optional and configurable
LLVM code generation
  - Define builtins & apply_n functions
  - Use boehm (for now)
Do closure conversion earlier and allow by-value variable capture
Usage analysis for better erasure
Add new Int type -- overloaded literals
Instantiate implicits at variable use sites
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
Cases
  Make Concrete syntax have deep patterns and desugar them
  Normalisation
Let(rec) definitions
Laziness
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
Do real GC with LLVM gcroots etc
Type classes
Specialisation pragma
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type
Test suite
Better error messages
Modules
Arity inference
Mixfix definitions and noncompounds?
Inductive families
FFI & More general way to define builtins (extern LLVM, C?)
