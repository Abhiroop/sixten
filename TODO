Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying ints be done in a principled way?
    Probably let that be handled by normalisation
  Propagate equalities from cases
  Sanity type-check the Abstract syntax
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
  Add tests for exactlyEqualisePats
Codegen
  Arity inference
  Use llvm-hs for llvm
  General cleanup
    Cases: direct returns
Compiler
  Add printing to compiler passes that are not VIX (make a MonadLog class?)
  Simplify/make consistent all the type synonyms
  Clean up MetaVar handling (not all modules need the full generality)
  Make code generation use VIX
  Try to get rid of zonking in normal TC operation
  Rename tc* VIXState accessors to vix*?
Error messages
  Write own error printer
  Make error message footnotes contain metavars
Language
  * Add builtin Byte type
    - Add alignment to type representation
      alignment (Tuple A B) = max (alignment A) (alignment B)
      size (Tuple A B) = size A + padding (size A) (alignment B) + size B
      padding byteIndex align = nearestBiggerMultiple align byteIndex - byteIndex
  * Add Nat type that is more matchable
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
    Overloaded literals
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
    Forcing
    Compute the size of a type by pattern-matching on indices if possible, allowing the definition of e.g. flat vectors:
      data Vector n A where
        Nil : Vector 0 A
        Cons : forall {n}. A -> Vector n A -> Vector (S n) a
  FFI & More general way to define builtins (extern LLVM, C?)
  Strings
  IO
Optimisations
  Inlining
  Common subexpressions
  Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
