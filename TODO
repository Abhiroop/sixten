Type checking
  Better checking for escaped vars
  Sanity type-check the Abstract syntax
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
  Add tests for exactlyEqualisePats
Codegen
  Arity inference
  Use llvm-hs for llvm
Compiler
  Add printing to compiler passes that are not VIX (make a MonadLog class?)
  Simplify/make consistent all the type synonyms
  Clean up MetaVar handling (not all modules need the full generality)
  Make code generation use VIX
  Try to get rid of zonking in normal TC operation
Error messages
  Write own error printer
  Make error message footnotes contain metavars
Language
  * Add alignment to type representation
    alignment (Tuple A B) = max (alignment A) (alignment B)
    size (Tuple A B) = size A + padding (size A) (alignment B) + size B
    padding byteIndex align = nearestBiggerMultiple align byteIndex - byteIndex
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
    Overloaded literals
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  * Inductive families
    Forcing
    Compute the representation of a type by pattern-matching on indices if possible, allowing the definition of e.g. flat vectors:
      type Vector n A where
        Nil : Vector 0 A
        Cons : forall {n}. A -> Vector n A -> Vector (S n) a
  FFI
    Rewrite builtins using extern C
    Make sure extern functions are inlined
    Add tests for FFI escaping
    Tests for regular and out params
    Top-level extern declarations
    Extern LLVM
  IO
Optimisations
  Inlining
  Common subexpressions
  Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 8
Organisation
  Put tests in directories by category
