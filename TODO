Type checking
  Better checking for escaped vars
  Sanity type-check the Abstract syntax
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
  Pattern synonyms (just normalise function applications in patterns and see if it ends up with a pattern)
Codegen
  Arity inference
  Use llvm-hs for llvm
Compiler
  Add printing to compiler passes that are not VIX (make a MonadLog class?)
  Simplify/make consistent all the type synonyms
  Clean up MetaVar handling (not all modules need the full generality)
  Make code generation use VIX
  Try to get rid of zonking in normal TC operation
Error messages
  Write own error printer
  Make error message footnotes contain metavars
  Use prettyprinter library
Language
  * Add alignment to type representation
    alignment (Tuple A B) = max (alignment A) (alignment B)
    size (Tuple A B) = size A + padding (size A) (alignment B) + size B
    padding byteIndex align = nearestBiggerMultiple align byteIndex - byteIndex
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
    Overloaded literals
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  * Modules
    Rename Builtin to Sixten.Builtin
    Add tests for using builtins qualified
    Split Processor into File, Def, and Modules processors
    Add multi-file tests and test simple imports and exports
    Revamp handling of constructors (currently doesn't really work)
  Mixfix definitions and noncompounds?
  * Inductive families
    Forcing
    Compute the representation of a type by pattern-matching on indices if possible, allowing the definition of e.g. flat vectors:
      type Vector n A where
        Nil : Vector 0 A
        Cons : forall {n}. A -> Vector n A -> Vector (S n) a
  FFI
    Top-level extern declarations
    Use `opt -internalize-public-api-list` to internalize extern C decls
    Extern LLVM
  IO
Optimisations
  Inlining
  Common subexpressions
  Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 8
