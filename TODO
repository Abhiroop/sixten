Constant-size transform
  map : (a -> b) -> List a -> List b
  map f xs = case xs of
    Nil -> Nil
    Cons x xs' -> Cons (f x) (Ref (map f (deref xs')))

  IndArg a | sizeof a <= 1 = a
  IndArg a = Ptr a
  IndRet a | sizeof a <= 1 = a
  IndRet a = Address -> Unit

  \xs. e
  \xs adr -> return e adr

  f xs

  let adr = alloc sz
  in read adr (f xs adr)

  return : a -> Address -> Unit
  alloc : Size -> Address
  read : Address -> Unit -> a

  Indirection part of annotation?

  indRet : forall {a}{A : Type a}. A -> IndRet A
  indArg : forall {a}{A : Type a}. A -> IndArg A

  ret : forall {a}{A : Type a}. IndRet A -> A
  arg : forall {a}{A : Type a}. IndArg A -> A

  map : (IndArg a -> IndRet b) -> IndArg (List a) -> IndRet (List b)
  map f xsp retAdr = case deref xsp of
    Nil -> write Nil retAdr
    Cons x xs' ->
      write Cons retAdr;
      f (Ref x) (retAdr + 1);
      let nextAdr = alloc (sizeof (List b))
      map f xs' nextAdr;
      write nextAdr (retAdr + 1 + sizeof (List b))

  map : (a -> b) -> Ptr (List a) -> Ptr (List b)
  map f xs = case deref xs of
    Nil -> Ref Nil
    Cons x xs' -> Ref (Cons (f x) (map f xs'))

  map : (IndArg a -> IndRet b) -> Ptr (List a) -> Ptr (List b)
  map f xsp = case deref xsp of
    Nil ->
      let res = alloc 1 in
      write Nil res;
      res
    Cons x xs' -> 
      let res = alloc (1 + sizeof a + 1) in
      write Cons res;
      f (xsp + 1) (res + 1);
      write (map f xs') (res + sizeof a + 1);
      res

LLVM code generation
Cleanup
Usage analysis for better erasure
Add new Int type
instantiate implicits at variable use sites?
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Reorder data to pass fewer sizes
    (Depends on relevance analysis and/or removal of unused args)
    Reorder data to enable tagged pointers?
Cases
  Make Concrete syntax have deep patterns and desugar them
  Normalisation
Let(rec) definitions
Laziness
Specialisation pragma
  data Strategy = Eager | Lazy

  @ : Type -> Strategy -> Type
  t @ Eager = t
  t @ Lazy = Ref (Lazy t)

  data Lazy a = Thunk (() -> a) | Blackhole | Forced a

  force : {s : Strategy} -> t @ s -> t
  force {Eager} t = t
  force {Lazy} t = run do
    x <- readRef t
    case x of
      Thunk f -> do
        writeRef t Blackhole
        let result = f ()
        writeRef t (Forced result)
        return result
      Blackhole -> error "<loop>"
      Forced result -> return result

  delay : {s : Strategy} -> (() -> t) -> t @ s
  delay {Eager} f = f ()
  delay {Lazy} f = newRef (Left f)

  data List s a = Nil | Cons a (List s a @ s)

  map : {s} -> (a -> b) -> List s a -> List s b
  map {s} = case s in \f xs. case xs of
    Nil -> Nil
    Cons x xs' -> Cons (f x) (map f xs')

  map s = case s of
    Eager -> mapEager
    Lazy  -> mapLazy

  mapEager f Nil = Nil
  mapEager f (Cons x xs) = Cons (f x) (mapEager f xs)

  mapLazy f Nil = Nil
  mapLazy f (Cons x xs) = Cons (f x) (newRef (Left (mapLazy f xs)))
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type

  Exists {X} (P : X -> Type) = {witness : x, proof : P witness}

  record {l : A | {l : B | r}} ?= record {l : A intersect B | r}
  intersection A B = {intersect : a, intersect : b}
    or not allowed?
  Parse
  Type-check
  Should make lenses?
  Codegen
Arity inference
Type classes
Test suite
Mixfix definitions and noncompounds?
Better error messages
Modules
Inductive families
