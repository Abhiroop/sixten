Type checking
  Better checking for escaped vars
    Add depths to all meta variables so we can track escaping
  Can the special-case equations for unifying sizes be done in a principled way?
  Propagate equalities from cases
  Make it so the following type checks when using `anno`:
    map : forall {b : Type ~{1}}. b -> Size
    map xs = map xs
Codegen
  Add Destructor calling convention for functions that return part of their argument
    To get rid of the memcpy from deref
  * Can case scrutinees and tail calls explicitly be of unspecified size?
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals
  Should things of known size > 1 be passed as LLVM arrays?
Compiler
  Make log function respond to verbosity and tag
  Clean up Syntax.{Telescope,Class,Branches,Data,Definition}
  * Test suite
    A list of programs and their expected outputs
    A list of programs that should not typecheck
  * Better error messages
Language
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  * Mutually recursive top-level definitions
  Named implicit arguments
  Laziness
  Make Concrete syntax have deep patterns and desugar them
  Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Can we have an Infinity size for things we can only hold in pointers?
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Usage analysis for better erasure
Runtime
  Do real GC with LLVM gcroots etc
