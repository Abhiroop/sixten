Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying ints be done in a principled way?
  Propagate equalities from cases
  Sanity type-check the Abstract syntax
Matching
  Coverage and overlap checking
  Parse and typecheck view patterns
Codegen
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals, e.g. `a = a`
  Should things of known size > 1 be passed as LLVM arrays?
  Use e.g. llvm-hs-kaleidoscope for llvm?
Compiler
  Look into a class for "(bi)transverse" (monadic/applicative hoisting)?
  Add printing to compiler passes that are not TCM (make a MonadLog class?)
  * Make converted signatures contain converted exprs to get rid of the back-and-forth conversions between slambda representations?
  Simplify/make consistent all the type synonyms
  Concretise some of the Context/MetaVary nonsense
  Clean up MetaVar handling (not all modules need the full generality)
Error messages
  Write own error printer
  Make error message footnotes contain metavars
Language
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Type classes
    Overloaded literals
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
  Strings
Optimisations
  Inlining
  Common subexpressions
  * Tagged pointers
    Reorder data to enable more?
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
