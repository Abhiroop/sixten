Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying sizes be done in a principled way?
  Propagate equalities from cases
Erasure
  Make sure that we don't transform functions to non-functions by erasing all arguments.
    e.g. `loop x = loop x : Void` should not have its argument removed.
  Type-based erasure of things of size 0 (they can be invented when needed instead of passed around)
Codegen
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals, e.g. `a = a`
  Should things of known size > 1 be passed as LLVM arrays?
Compiler
  Add printing to compiler passes that are not TCM (make a MonadLog class?)
  Concretise some of the Context/MetaVary nonsense
  Clean up MetaVar handling (not all modules need the full generality)
Error messages
  Make error message footnotes contain metavars
Language
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  * Make Concrete syntax have deep patterns and desugar them
  Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Can we have an Infinity size for things we can only hold in pointers?
Optimisations
  Inlining
  Common subexpressions
  Case of known
  * Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
