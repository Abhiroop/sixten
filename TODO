Type checking
  [2] Instantiate implicits at variable use sites
  [1] Why doesn't the following compile without the signature?
    print2 = printSize (sum (map (\(f : Size -> Size). f 2) (map (add3 1) testList)))
Codegen
  [3] Make lifted functions private
  Add Destructor calling convention for functions that return part of their argument
    To get rid of the memcpy from deref
  Make case expressions return Direct vars if possible
  Can case scrutinees and tail calls explicitly be of unspecified size?
  Clean up Syntax.{Telescope,Class,Branches,Data,Definition}
  Arity inference
Compiler
  [] Make log function respond to verbosity and tag
  Test suite
  Better error messages
Language
  Add new Int type -- overloaded literals
  Let(rec) definitions
  Mutually recursive top-level definitions
  Laziness
  Cases
    Make Concrete syntax have deep patterns and desugar them
    Normalisation
  Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Can we have an Infinity size for things we can only hold in pointers?
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Usage analysis for better erasure
Globals
  Make literals llvm `constant`s
  Add error message for circular globals
Runtime
  Do real GC with LLVM gcroots etc
