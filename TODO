LLVM code generation
  - Define builtins & apply_n functions
  Globals
    - Heap-alloc globals not of constant size
    - Make globals of constant size arrays?
    - Make literals llvm `constant`s
  - Use boehm (for now)
  - Support existential sizes in constructors when pattern-matching
Make printing of passes optional and configurable
Usage analysis for better erasure
Add new Int type -- overloaded literals
Instantiate implicits at variable use sites
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
Cases
  Make Concrete syntax have deep patterns and desugar them
  Normalisation
Let(rec) definitions
Mutually recursive definitions
Laziness
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
Do real GC with LLVM gcroots etc
Type classes
Specialisation pragma
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type
Test suite
Better error messages
Modules
Arity inference
Mixfix definitions and noncompounds?
Inductive families
FFI & More general way to define builtins (extern LLVM, C?)
