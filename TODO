Type checking
  * Instantiate inferred types such that the map4 example works
  Can the special-case equations for unifying sizes be done in a principled way?
  Gather applications and do non-vars first for better propagation in checkType
  Propagate equalities from cases
Codegen
  Add Destructor calling convention for functions that return part of their argument
    To get rid of the memcpy from deref
  * Can case scrutinees and tail calls explicitly be of unspecified size?
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals
Compiler
  * Make it automatically compile the llvm bytecode
  Make log function respond to verbosity and tag
  Clean up Syntax.{Telescope,Class,Branches,Data,Definition}
  * Test suite
    A list of programs and their expected outputs
    A list of programs that should not typecheck
  * Better error messages
Language
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  * Mutually recursive top-level definitions
  Named implicit arguments
  Laziness
  Make Concrete syntax have deep patterns and desugar them
  Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
    Maybe just make the usage analysis pass aware of this
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Can we have an Infinity size for things we can only hold in pointers?
Optimisations
  Inlining
  Common subexpressions
  Case of known
  Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Usage analysis for better erasure
Runtime
  Do real GC with LLVM gcroots etc
