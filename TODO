Type checking
  Better checking for escaped vars
  Can the special-case equations for unifying sizes be done in a principled way?
  Propagate equalities from cases
  Sanity type-check the Abstract syntax
  Match coverage checking
Erasure
  Make sure that we don't transform functions to non-functions by erasing all arguments.
    e.g. `loop x = loop x : Void` should not have its argument removed.
  Type-based erasure of things of size 0 (they can be invented when needed instead of passed around)
Codegen
  Arity inference
  Globals
    Make literals llvm `constant`s
    Add error message for circular globals, e.g. `a = a`
  Should things of known size > 1 be passed as LLVM arrays?
Compiler
  Cleanups:
    Get rid of recursiveAbstract, instantiateDef
    Rename Wet and Dry to unscoped and scoping?
    Go through all code and remove unused things
  Use e.g. llvm-hs-kaleidoscope for llvm?
  Add printing to compiler passes that are not TCM (make a MonadLog class?)
  Simplify/make consistent all the type synonyms
  Concretise some of the Context/MetaVary nonsense
  Clean up MetaVar handling (not all modules need the full generality)
  Remove Bound instances and only use GlobalBound
  Make a version of e.g. forMTele that's not recursive, but instead gives access to the partial result (use slice cleverly?)
Error messages
  Write own error printer
  Make error message footnotes contain metavars
Language
  Add new Int type -- overloaded literals
  * Let(rec) definitions
  Named implicit arguments (maybe names should be mandatory?)
  Laziness
  Desugar patterns of different arity and with differing implicit args
  * Type classes
  Row polymorphism
    r : Row : Type
    {l = A} : {l : A} : Type
  Specialisation pragma
  Modules
  Mixfix definitions and noncompounds?
  Inductive families
  FFI & More general way to define builtins (extern LLVM, C?)
Size types
  Can the size be made abstract, e.g. `List A : Type {sizeof (List A)}`?
  Change Size to runtime representation, which can include:
    * Allocation strategy
    * Size
    * GC info (e.g. positions of pointers)
    * Functions can be of type `Type {ClosureRep}` where ClosureRep is magic
  Can we have an Infinity size for things we can only hold in pointers?
  ListRep : max 1 (1 + sizeof A + sizeof (Ptr (List A)))
Optimisations
  Inlining
  Common subexpressions
  Case of known
  * Tagged pointers
    Reorder data to enable more?
  App of lambda -> let
  Join point let bindings
Runtime
  Do real GC with LLVM gcroots etc
  Closures
    Store the arity as a bitfield where the highest set bit determines the
    arity, and the other bits determine the arguments of size 1
