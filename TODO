Arity inference
LLVM code generation
Usage analysisis for better erasure
Add new Int type
instantiate implicits at variable use sites?
Size types
  How to cleanly make `(a -> b) : Type 0` when `b : Type 0`?
  Reorder data to pass fewer sizes
    (Depends on relevance analysis and/or removal of unused args)
    Reorder data to enable tagged pointers?
Javascript code generation
Cases
  Make Concrete syntax have deep patterns and desugar them
  Normalisation
Let definitions
Laziness
Specialisation pragma
  data Strategy = Eager | Lazy

  @ : Type -> Strategy -> Type
  t @ Eager = t
  t @ Lazy = Ref (Lazy t)

  data Lazy a = Thunk (() -> a) | Blackhole | Forced a

  force : {s : Strategy} -> t @ s -> t
  force {Eager} t = t
  force {Lazy} t = run do
    x <- readRef t
    case x of
      Thunk f -> do
        writeRef t Blackhole
        let result = f ()
        writeRef t (Forced result)
        return result
      Blackhole -> error "<loop>"
      Forced result -> return result

  delay : {s : Strategy} -> (() -> t) -> t @ s
  delay {Eager} f = f ()
  delay {Lazy} f = newRef (Left f)

  data List s a = Nil | Cons a (List s a @ s)

  map : {s} -> (a -> b) -> List s a -> List s b
  map {s} = case s in \f xs. case xs of
    Nil -> Nil
    Cons x xs' -> Cons (f x) (map f xs')

  map s = case s of
    Eager -> mapEager
    Lazy  -> mapLazy

  mapEager f Nil = Nil
  mapEager f (Cons x xs) = Cons (f x) (mapEager f xs)

  mapLazy f Nil = Nil
  mapLazy f (Cons x xs) = Cons (f x) (newRef (Left (mapLazy f xs)))
Row polymorphism
  r : Row : Type
  {l = A} : {l : A} : Type

  Exists {X} (P : X -> Type) = {witness : x, proof : P witness}

  record {l : A | {l : B | r}} ?= record {l : A intersect B | r}
  intersection A B = {intersect : a, intersect : b}
    or not allowed?
  Parse
  Type-check
  Should make lenses?
  Codegen
Type classes
Test suite
Mixfix definitions and noncompounds?
Better error messages
Modules
Inductive families
