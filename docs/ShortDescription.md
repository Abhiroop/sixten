Sixten is a language and compiler (targeting LLVM) for an experimental
dependently typed functional language where the novel feature is that all data
types are unpacked (sort of like in C and C++, where the data is contiguous in
memory if you nest a struct inside a struct, unless you specify that you have a
_pointer to_ a struct), and where you can define functions (and data types)
that are polymorphic over such data types.  These functions are compiled
without using template instantiation which means that Sixten avoids the code
size explosion and anti-modularity associated with languages using template
instantiation.

To take a concrete example, the definition of a linked list of elements of type
`A` in Sixten is something like:

```
data List A = Nil | Cons A (Ref (List A))
```

This says that a list is either the empty list, `Nil`, or it's a `Cons` element
which consists of an `A` element and a reference to the rest of the list.

The data representation of a `Cons` cell has the data for `A` _next to_ the
pointer to the rest of the list. Compare this to most other high-level
languages, where the `Cons` cell would contain a _pointer to_ an `A`.

If you define a function that's polymorphic over the type of elements in a
list, such as `map : forall A B. (A -> B) -> List A -> List B`, only a single
definition will be generated by the compiler. Contrast this to C++ which would
generate a new version of `map` for all combinations of types `A` and `B` that
it's used with.

The thing that makes this tick is what might be called implicit size
polymorphism.  The program that the programmer writes is elaborated into an
intermediate representation where the sizes of polymorphic types are passed as
arguments to the functions that use them. In the case of the `map` function
above, the compiled version of the function will take additional arguments
representing the size of the types `A` and `B`, such that it knows how to
destruct the argument list (the `List A`) and how to construct the result (the
`List B`).

The hope is that this language will enable writing programs that are more
modular, more efficient, and more cache friendly than what can be achieved in
high-level languages today.
